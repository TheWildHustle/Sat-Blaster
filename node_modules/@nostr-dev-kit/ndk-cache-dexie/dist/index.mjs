// src/index.ts
import { NDKEvent, NDKRelay, deserialize, profileFromEvent } from "@nostr-dev-kit/ndk";
import createDebug from "debug";
import { matchFilter } from "nostr-tools";

// src/db.ts
import Dexie from "dexie";
var Database = class extends Dexie {
  users;
  events;
  eventTags;
  nip05;
  lnurl;
  relayStatus;
  constructor(name) {
    super(name);
    this.version(11).stores({
      users: "&pubkey",
      events: "&id, kind",
      eventTags: "&tagValue",
      nip05: "&nip05",
      lnurl: "&pubkey",
      relayStatus: "&url"
    });
  }
};
var db;
function createDatabase(name) {
  db = new Database(name);
}

// src/lru-cache.ts
import { LRUCache } from "typescript-lru-cache";
var CacheHandler = class {
  cache;
  dirtyKeys = /* @__PURE__ */ new Set();
  options;
  debug;
  indexes;
  isSet = false;
  constructor(options) {
    this.debug = options.debug;
    this.options = options;
    if (options.maxSize > 0) {
      this.cache = new LRUCache({ maxSize: options.maxSize });
      setInterval(() => this.dump(), 1e3 * 10);
    }
    this.indexes = /* @__PURE__ */ new Map();
  }
  getSet(key) {
    return this.cache?.get(key);
  }
  /**
   * Get all entries that match the filter.
   */
  getAllWithFilter(filter) {
    const ret = /* @__PURE__ */ new Map();
    this.cache?.forEach((val, key) => {
      if (filter(key, val)) {
        ret.set(key, val);
      }
    });
    return ret;
  }
  get(key) {
    return this.cache?.get(key);
  }
  async getWithFallback(key, table) {
    let entry = this.get(key);
    if (!entry) {
      this.debug(`Cache miss for key ${JSON.stringify(key)}`);
      entry = await table.get(key);
      if (entry) {
        this.set(key, entry);
      }
    }
    return entry;
  }
  async getManyWithFallback(keys, table) {
    const entries = [];
    const missingKeys = [];
    for (const key of keys) {
      const entry = this.get(key);
      if (entry)
        entries.push(entry);
      else
        missingKeys.push(key);
    }
    if (entries.length > 0) {
      this.debug(`Cache hit for keys ${entries.length} and miss for ${missingKeys.length} keys`);
    }
    if (missingKeys.length > 0) {
      const startTime = Date.now();
      const missingEntries = await table.bulkGet(missingKeys);
      const endTime = Date.now();
      let foundKeys = 0;
      for (const entry of missingEntries) {
        if (entry) {
          this.set(entry.id, entry);
          entries.push(entry);
          foundKeys++;
        }
      }
      this.debug(`Time spent querying database: ${endTime - startTime}ms for ${missingKeys.length} keys, which added ${foundKeys} entries to the cache`);
    }
    return entries;
  }
  add(key, value, dirty = true) {
    const existing = this.get(key) ?? /* @__PURE__ */ new Set();
    existing.add(value);
    this.cache?.set(key, existing);
    if (dirty)
      this.dirtyKeys.add(key);
  }
  set(key, value, dirty = true) {
    this.cache?.set(key, value);
    if (dirty)
      this.dirtyKeys.add(key);
    for (const [attribute, index] of this.indexes.entries()) {
      const indexKey = value[attribute];
      if (indexKey) {
        const indexValue = index.get(indexKey) || /* @__PURE__ */ new Set();
        indexValue.add(key);
        index.set(indexKey, indexValue);
      }
    }
  }
  size() {
    return this.cache?.size || 0;
  }
  delete(key) {
    this.cache?.delete(key);
    this.dirtyKeys.add(key);
  }
  async dump() {
    if (this.dirtyKeys.size > 0) {
      await this.options.dump(this.dirtyKeys, this.cache);
      this.dirtyKeys.clear();
    }
  }
  addIndex(attribute) {
    this.indexes.set(attribute, new LRUCache({ maxSize: this.options.maxSize }));
  }
  getFromIndex(attribute, key) {
    const ret = /* @__PURE__ */ new Set();
    this.indexes.get(attribute)?.get(key)?.forEach((key2) => {
      const entry = this.get(key2);
      if (entry)
        ret.add(entry);
    });
    return ret;
  }
};

// src/caches/profiles.ts
async function profilesWarmUp(cacheHandler, users) {
  await users.each((user) => {
    cacheHandler.set(user.pubkey, user.profile, false);
  });
}
var profilesDump = (users, debug) => {
  return async (dirtyKeys, cache) => {
    const profiles = [];
    for (const pubkey of dirtyKeys) {
      const profile = cache.get(pubkey);
      if (profile) {
        profiles.push({
          pubkey,
          profile,
          createdAt: Date.now()
        });
      }
    }
    if (profiles.length) {
      debug(`Saving ${profiles.length} profiles to database`);
      await users.bulkPut(profiles);
    }
    dirtyKeys.clear();
  };
};

// src/caches/zapper.ts
async function zapperWarmUp(cacheHandler, lnurls) {
  await lnurls.each((lnurl) => {
    cacheHandler.set(
      lnurl.pubkey,
      { document: lnurl.document, fetchedAt: lnurl.fetchedAt },
      false
    );
  });
}
var zapperDump = (lnurls, debug) => {
  return async (dirtyKeys, cache) => {
    const entries = [];
    for (const pubkey of dirtyKeys) {
      const entry = cache.get(pubkey);
      if (entry) {
        entries.push({
          pubkey,
          ...entry
        });
      }
    }
    if (entries.length) {
      debug(`Saving ${entries.length} zapper cache entries to database`);
      await lnurls.bulkPut(entries);
    }
    dirtyKeys.clear();
  };
};

// src/caches/nip05.ts
async function nip05WarmUp(cacheHandler, nip05s) {
  await nip05s.each((nip05) => {
    cacheHandler.set(nip05.nip05, nip05, false);
  });
}
var nip05Dump = (nip05s, debug) => {
  return async (dirtyKeys, cache) => {
    const entries = [];
    for (const nip05 of dirtyKeys) {
      const entry = cache.get(nip05);
      if (entry) {
        entries.push({
          nip05,
          ...entry
        });
      }
    }
    if (entries.length) {
      debug(`Saving ${entries.length} NIP-05 cache entries to database`);
      await nip05s.bulkPut(entries);
    }
    dirtyKeys.clear();
  };
};

// src/caches/events.ts
async function eventsWarmUp(cacheHandler, events) {
  await events.each((event) => {
    cacheHandler.set(event.id, event, false);
  });
}
var eventsDump = (events, debug) => {
  return async (dirtyKeys, cache) => {
    const entries = [];
    for (const event of dirtyKeys) {
      const entry = cache.get(event);
      if (entry)
        entries.push(entry);
    }
    if (entries.length > 0) {
      debug(`Saving ${entries.length} events cache entries to database`);
      await events.bulkPut(entries);
    }
    dirtyKeys.clear();
  };
};

// src/caches/event-tags.ts
async function eventTagsWarmUp(cacheHandler, eventTags) {
  await eventTags.each((event) => {
    cacheHandler.add(event.tagValue, event.eventId, false);
  });
}
var eventTagsDump = (eventTags, debug) => {
  return async (dirtyKeys, cache) => {
    const entries = [];
    for (const tagValue of dirtyKeys) {
      const eventIds = cache.get(tagValue);
      if (eventIds) {
        for (const eventId of eventIds)
          entries.push({ tagValue, eventId });
      }
    }
    if (entries.length > 0) {
      debug(`Saving ${entries.length} events cache entries to database`);
      await eventTags.bulkPut(entries);
    }
    dirtyKeys.clear();
  };
};

// src/caches/relay-info.ts
async function relayInfoWarmUp(cacheHandler, relayStatus) {
  await relayStatus.each((entry) => {
    cacheHandler.set(entry.url, {
      url: entry.url,
      updatedAt: entry.updatedAt,
      lastConnectedAt: entry.lastConnectedAt,
      dontConnectBefore: entry.dontConnectBefore
    }, false);
  });
}
var relayInfoDump = (relayStatus, debug) => {
  return async (dirtyKeys, cache) => {
    const entries = [];
    for (const url of dirtyKeys) {
      const info = cache.get(url);
      if (info) {
        entries.push({
          url,
          updatedAt: info.updatedAt,
          lastConnectedAt: info.lastConnectedAt,
          dontConnectBefore: info.dontConnectBefore
        });
      }
    }
    if (entries.length > 0) {
      debug(`Saving ${entries.length} relay status cache entries to database`);
      await relayStatus.bulkPut(entries);
    }
    dirtyKeys.clear();
  };
};

// src/index.ts
var NDKCacheAdapterDexie = class {
  debug;
  expirationTime;
  locking = true;
  ready = false;
  profiles;
  zappers;
  nip05s;
  events;
  eventTags;
  relayInfo;
  warmedUp = false;
  warmUpPromise;
  devMode = false;
  _onReady;
  constructor(opts = {}) {
    createDatabase(opts.dbName || "ndk");
    this.debug = opts.debug || createDebug("ndk:dexie-adapter");
    this.expirationTime = opts.expirationTime || 3600;
    this.profiles = new CacheHandler({
      maxSize: opts.profileCacheSize || 1e5,
      dump: profilesDump(db.users, this.debug),
      debug: this.debug
    });
    this.zappers = new CacheHandler({
      maxSize: opts.zapperCacheSize || 200,
      dump: zapperDump(db.lnurl, this.debug),
      debug: this.debug
    });
    this.nip05s = new CacheHandler({
      maxSize: opts.nip05CacheSize || 1e3,
      dump: nip05Dump(db.nip05, this.debug),
      debug: this.debug
    });
    this.events = new CacheHandler({
      maxSize: opts.eventCacheSize || 15e4,
      dump: eventsDump(db.events, this.debug),
      debug: this.debug
    });
    this.events.addIndex("pubkey");
    this.eventTags = new CacheHandler({
      maxSize: opts.eventTagsCacheSize || 1e5,
      dump: eventTagsDump(db.eventTags, this.debug),
      debug: this.debug
    });
    this.relayInfo = new CacheHandler({
      maxSize: 500,
      debug: this.debug,
      dump: relayInfoDump(db.relayStatus, this.debug)
    });
    const startTime = Date.now();
    this.warmUpPromise = Promise.allSettled([
      profilesWarmUp(this.profiles, db.users),
      zapperWarmUp(this.zappers, db.lnurl),
      nip05WarmUp(this.nip05s, db.nip05),
      eventsWarmUp(this.events, db.events),
      eventTagsWarmUp(this.eventTags, db.eventTags),
      relayInfoWarmUp(this.relayInfo, db.relayStatus)
    ]);
    this.warmUpPromise.then(() => {
      const endTime = Date.now();
      this.warmedUp = true;
      this.ready = true;
      this.debug("Warm up completed, time", endTime - startTime, "ms");
      if (this._onReady)
        this._onReady();
    });
  }
  onReady(callback) {
    this._onReady = callback;
  }
  async query(subscription) {
    if (!this.warmedUp) {
      const startTime2 = Date.now();
      await this.warmUpPromise;
      this.debug("froze query for", Date.now() - startTime2, "ms");
    }
    const startTime = Date.now();
    subscription.filters.map((filter) => this.processFilter(filter, subscription));
    const dur = Date.now() - startTime;
    if (dur > 100)
      this.debug("query took", dur, "ms", subscription.filter);
  }
  async fetchProfile(pubkey) {
    if (!this.profiles)
      return null;
    let profile = await this.profiles.getWithFallback(pubkey, db.users);
    return profile || null;
  }
  async getProfiles(fn) {
    if (!this.profiles)
      return;
    return this.profiles.getAllWithFilter(fn);
  }
  saveProfile(pubkey, profile) {
    this.profiles.set(pubkey, profile);
  }
  async loadNip05(nip05, maxAgeForMissing = 3600) {
    const cache = this.nip05s?.get(nip05);
    if (cache) {
      if (cache.profile === null) {
        if (cache.fetchedAt + maxAgeForMissing * 1e3 < Date.now())
          return "missing";
        return null;
      }
      try {
        return JSON.parse(cache.profile);
      } catch (e) {
        return "missing";
      }
    }
    const nip = await db.nip05.get({ nip05 });
    if (!nip)
      return "missing";
    const now = Date.now();
    if (nip.profile === null) {
      if (nip.fetchedAt + maxAgeForMissing * 1e3 < now)
        return "missing";
      return null;
    }
    try {
      return JSON.parse(nip.profile);
    } catch (e) {
      return "missing";
    }
  }
  async saveNip05(nip05, profile) {
    try {
      const document = profile ? JSON.stringify(profile) : null;
      this.nip05s.set(nip05, { profile: document, fetchedAt: Date.now() });
    } catch (error) {
      console.error("Failed to save NIP-05 profile for nip05:", nip05, error);
    }
  }
  async loadUsersLNURLDoc(pubkey, maxAgeInSecs = 86400, maxAgeForMissing = 3600) {
    const cache = this.zappers?.get(pubkey);
    if (cache) {
      if (cache.document === null) {
        if (cache.fetchedAt + maxAgeForMissing * 1e3 < Date.now())
          return "missing";
        return null;
      }
      try {
        return JSON.parse(cache.document);
      } catch (e) {
        return "missing";
      }
    }
    const lnurl = await db.lnurl.get({ pubkey });
    if (!lnurl)
      return "missing";
    const now = Date.now();
    if (lnurl.fetchedAt + maxAgeInSecs * 1e3 < now)
      return "missing";
    if (lnurl.document === null) {
      if (lnurl.fetchedAt + maxAgeForMissing * 1e3 < now)
        return "missing";
      return null;
    }
    try {
      return JSON.parse(lnurl.document);
    } catch (e) {
      return "missing";
    }
  }
  async saveUsersLNURLDoc(pubkey, doc) {
    try {
      const document = doc ? JSON.stringify(doc) : null;
      this.zappers?.set(pubkey, { document, fetchedAt: Date.now() });
    } catch (error) {
      console.error("Failed to save LNURL document for pubkey:", pubkey, error);
    }
  }
  processFilter(filter, subscription) {
    const _filter = { ...filter };
    delete _filter.limit;
    const filterKeys = Object.keys(_filter || {}).sort();
    let exit = false;
    try {
      if (this.byNip33Query(filterKeys, filter, subscription))
        return;
      if (this.byAuthors(filter, subscription))
        return;
      if (this.byIdsQuery(filter, subscription))
        return;
      if (this.byTags(filter, subscription))
        return;
    } catch (error) {
      console.error(error);
    }
  }
  async deleteEvent(event) {
    this.events.delete(event.tagId());
    await db.events.where({ id: event.tagId() }).delete();
  }
  async setEvent(event, filters, relay) {
    if (event.kind === 0) {
      if (!this.profiles)
        return;
      try {
        const profile = profileFromEvent(event);
        this.saveProfile(event.pubkey, profile);
      } catch {
        this.debug(`Failed to save profile for pubkey: ${event.pubkey}`);
      }
    }
    let addEvent = true;
    if (event.isParamReplaceable()) {
      const existingEvent = await this.events.get(event.tagId());
      if (existingEvent && event.created_at && existingEvent.createdAt > event.created_at) {
        addEvent = false;
      }
    }
    if (addEvent) {
      this.events.set(event.tagId(), {
        id: event.tagId(),
        pubkey: event.pubkey,
        kind: event.kind,
        createdAt: event.created_at,
        relay: relay?.url,
        event: event.serialize(true, true)
      });
      if (event.kind !== 3) {
        event.tags.forEach((tag) => {
          if (tag[0].length !== 1)
            return;
          this.eventTags.add(tag[0] + tag[1], event.tagId());
        });
      }
    }
  }
  updateRelayStatus(url, info) {
    const val = { url, updatedAt: Date.now(), ...info };
    this.relayInfo.set(url, val);
  }
  getRelayStatus(url) {
    const a = this.relayInfo.get(url);
    if (a) {
      return {
        lastConnectedAt: a.lastConnectedAt,
        dontConnectBefore: a.dontConnectBefore
      };
    }
  }
  /**
   * Searches by authors
   */
  byAuthors(filter, subscription) {
    if (!filter.authors)
      return false;
    let total = 0;
    for (const pubkey of filter.authors) {
      let events = Array.from(this.events.getFromIndex("pubkey", pubkey));
      const prev = events.length;
      if (filter.kinds)
        events = events.filter((e) => filter.kinds.includes(e.kind));
      foundEvents(subscription, events, filter);
      total += events.length;
    }
    return true;
  }
  /**
   * Searches by ids
   */
  byIdsQuery(filter, subscription) {
    if (filter.ids) {
      for (const id of filter.ids) {
        const event = this.events.get(id);
        if (event)
          foundEvent(subscription, event, event.relay);
      }
      return true;
    }
    return false;
  }
  /**
   * Searches by NIP-33
   */
  byNip33Query(filterKeys, filter, subscription) {
    const f = ["#d", "authors", "kinds"];
    const hasAllKeys = filterKeys.length === f.length && f.every((k) => filterKeys.includes(k));
    if (hasAllKeys && filter.kinds && filter.authors) {
      for (const kind of filter.kinds) {
        const replaceableKind = kind >= 3e4 && kind < 4e4;
        if (!replaceableKind)
          continue;
        for (const author of filter.authors) {
          for (const dTag of filter["#d"]) {
            const replaceableId = `${kind}:${author}:${dTag}`;
            const event = this.events.get(replaceableId);
            if (event)
              foundEvent(subscription, event, event.relay);
          }
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Searches by tags and optionally filters by tags
   */
  byTags(filter, subscription) {
    const tagFilters = Object.entries(filter).filter(([filter2]) => filter2.startsWith("#") && filter2.length === 2).map(([filter2, values]) => [filter2[1], values]);
    if (tagFilters.length === 0)
      return false;
    for (const [tag, values] of tagFilters) {
      for (const value of values) {
        const tagValue = tag + value;
        const eventIds = this.eventTags.getSet(tagValue);
        if (!eventIds)
          continue;
        eventIds.forEach((id) => {
          const event = this.events.get(id);
          if (!event)
            return;
          if (!filter.kinds || filter.kinds.includes(event.kind)) {
            foundEvent(subscription, event, event.relay);
          }
        });
      }
    }
    return true;
  }
};
function checkEventMatchesFilter(event, filter) {
  let deserializedEvent;
  try {
    deserializedEvent = deserialize(event.event);
    if (!matchFilter(filter, deserializedEvent))
      return;
  } catch (e) {
    console.log("failed to parse event", e);
    return;
  }
  const ndkEvent = new NDKEvent(void 0, deserializedEvent);
  const relay = event.relay ? new NDKRelay(event.relay) : void 0;
  ndkEvent.relay = relay;
  return ndkEvent;
}
function foundEvents(subscription, events, filter) {
  for (const event of events) {
    foundEvent(subscription, event, event.relay, filter);
  }
}
function foundEvent(subscription, event, relayUrl, filter) {
  try {
    const deserializedEvent = deserialize(event.event);
    if (filter && !matchFilter(filter, deserializedEvent))
      return;
    const ndkEvent = new NDKEvent(void 0, deserializedEvent);
    const relay = relayUrl ? subscription.pool.getRelay(relayUrl) : void 0;
    ndkEvent.relay = relay;
    subscription.eventReceived(ndkEvent, relay, true);
  } catch (e) {
    console.error("failed to deserialize event", e);
  }
}
export {
  checkEventMatchesFilter,
  db,
  NDKCacheAdapterDexie as default,
  foundEvent,
  foundEvents
};
