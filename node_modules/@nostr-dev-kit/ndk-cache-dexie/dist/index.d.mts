import { NDKUserProfile, NDKCacheAdapter, NDKSubscription, Hexpubkey, ProfilePointer, NDKLnUrlData, NDKEvent, NDKFilter, NDKRelay, NDKCacheRelayInfo } from '@nostr-dev-kit/ndk';
import Dexie, { Table } from 'dexie';
import { LRUCache } from 'typescript-lru-cache';

interface User {
    pubkey: string;
    profile: NDKUserProfile;
    createdAt: number;
}
interface Event {
    id: string;
    pubkey: string;
    kind: number;
    createdAt: number;
    relay?: string;
    event: string;
}
interface EventTag {
    eventId: string;
    tagValue: string;
}
interface Nip05 {
    nip05: string;
    profile: string | null;
    fetchedAt: number;
}
interface Lnurl {
    pubkey: string;
    document: string | null;
    fetchedAt: number;
}
interface RelayStatus {
    url: string;
    updatedAt: number;
    lastConnectedAt?: number;
    dontConnectBefore?: number;
}
declare class Database extends Dexie {
    users: Table<User>;
    events: Table<Event>;
    eventTags: Table<EventTag>;
    nip05: Table<Nip05>;
    lnurl: Table<Lnurl>;
    relayStatus: Table<RelayStatus>;
    constructor(name: string);
}
declare let db: Database;

interface CacheOptions<T> {
    maxSize: number;
    dump: (dirtyKeys: Set<string>, cache: LRUCache<string, T>) => Promise<void>;
    debug: debug.IDebugger;
}
declare class CacheHandler<T> {
    private cache?;
    private dirtyKeys;
    private options;
    private debug;
    indexes: Map<string, LRUCache<string, Set<string>>>;
    isSet: boolean;
    constructor(options: CacheOptions<T>);
    getSet(key: string): Set<T> | null;
    /**
     * Get all entries that match the filter.
     */
    getAllWithFilter(filter: (key: string, val: T) => boolean): Map<string, T>;
    get(key: string): T | null | undefined;
    getWithFallback(key: string, table: Table): Promise<T | null | undefined>;
    getManyWithFallback(keys: string[], table: Table): Promise<T[]>;
    add<K>(key: string, value: K, dirty?: boolean): void;
    set(key: string, value: T, dirty?: boolean): void;
    size(): number;
    delete(key: string): void;
    private dump;
    addIndex<T>(attribute: string): void;
    getFromIndex(attribute: string, key: string): Set<T>;
}

type ZapperCacheEntry = {
    document: string | null;
    fetchedAt: number;
};

type Nip05CacheEntry = {
    profile: string | null;
    fetchedAt: number;
};

type EventCacheEntry = Event;

type EventTagCacheEntry = string;

interface NDKCacheAdapterDexieOptions {
    /**
     * The name of the database to use
     */
    dbName?: string;
    /**
     * Debug instance to use for logging
     */
    debug?: debug.IDebugger;
    /**
     * The number of seconds to store events in Dexie (IndexedDB) before they expire
     * Defaults to 3600 seconds (1 hour)
     */
    expirationTime?: number;
    /**
     * Number of profiles to keep in an LRU cache
     */
    profileCacheSize?: number;
    zapperCacheSize?: number;
    nip05CacheSize?: number;
    eventCacheSize?: number;
    eventTagsCacheSize?: number;
}
declare class NDKCacheAdapterDexie implements NDKCacheAdapter {
    debug: debug.Debugger;
    private expirationTime;
    readonly locking = true;
    ready: boolean;
    profiles: CacheHandler<NDKUserProfile>;
    zappers: CacheHandler<ZapperCacheEntry>;
    nip05s: CacheHandler<Nip05CacheEntry>;
    events: CacheHandler<EventCacheEntry>;
    eventTags: CacheHandler<EventTagCacheEntry>;
    relayInfo: CacheHandler<RelayStatus>;
    private warmedUp;
    private warmUpPromise;
    devMode: boolean;
    _onReady?: () => void;
    constructor(opts?: NDKCacheAdapterDexieOptions);
    onReady(callback: () => void): void;
    query(subscription: NDKSubscription): Promise<void>;
    fetchProfile(pubkey: Hexpubkey): Promise<NDKUserProfile | null>;
    getProfiles(fn: (pubkey: Hexpubkey, profile: NDKUserProfile) => boolean): Promise<Map<Hexpubkey, NDKUserProfile> | undefined>;
    saveProfile(pubkey: Hexpubkey, profile: NDKUserProfile): void;
    loadNip05(nip05: string, maxAgeForMissing?: number): Promise<ProfilePointer | null | "missing">;
    saveNip05(nip05: string, profile: ProfilePointer | null): Promise<void>;
    loadUsersLNURLDoc?(pubkey: Hexpubkey, maxAgeInSecs?: number, maxAgeForMissing?: number): Promise<NDKLnUrlData | null | "missing">;
    saveUsersLNURLDoc(pubkey: Hexpubkey, doc: NDKLnUrlData | null): Promise<void>;
    private processFilter;
    deleteEvent(event: NDKEvent): Promise<void>;
    setEvent(event: NDKEvent, filters: NDKFilter[], relay?: NDKRelay): Promise<void>;
    updateRelayStatus(url: string, info: NDKCacheRelayInfo): void;
    getRelayStatus(url: string): NDKCacheRelayInfo | undefined;
    /**
     * Searches by authors
     */
    private byAuthors;
    /**
     * Searches by ids
     */
    private byIdsQuery;
    /**
     * Searches by NIP-33
     */
    private byNip33Query;
    /**
     * Searches by tags and optionally filters by tags
     */
    private byTags;
}
declare function checkEventMatchesFilter(event: Event, filter: NDKFilter): NDKEvent | undefined;
declare function foundEvents(subscription: NDKSubscription, events: Event[], filter?: NDKFilter): void;
declare function foundEvent(subscription: NDKSubscription, event: Event, relayUrl: WebSocket["url"] | undefined, filter?: NDKFilter): void;

export { checkEventMatchesFilter, db, NDKCacheAdapterDexie as default, foundEvent, foundEvents };
