{
  "version": 3,
  "sources": ["../../lib0/mutex.js", "../../lib0/diff.js", "../../y-prosemirror/src/plugins/keys.js", "../../y-prosemirror/src/plugins/sync-plugin.js", "../../y-prosemirror/src/lib.js", "../../y-prosemirror/src/plugins/undo-plugin.js", "../../@tiptap/extension-collaboration/src/collaboration.ts", "../../@tiptap/extension-collaboration/src/helpers/isChangeOrigin.ts"],
  "sourcesContent": ["/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nexport const createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n", "/**\n * Efficient diffs.\n *\n * @module diff\n */\n\nimport { equalityStrict } from './function.js'\n\n/**\n * A SimpleDiff describes a change on a String.\n *\n * ```js\n * console.log(a) // the old value\n * console.log(b) // the updated value\n * // Apply changes of diff (pseudocode)\n * a.remove(diff.index, diff.remove) // Remove `diff.remove` characters\n * a.insert(diff.index, diff.insert) // Insert `diff.insert`\n * a === b // values match\n * ```\n *\n * @typedef {Object} SimpleDiff\n * @property {Number} index The index where changes were applied\n * @property {Number} remove The number of characters to delete starting\n *                                  at `index`.\n * @property {T} insert The new text to insert at `index` after applying\n *                           `delete`\n *\n * @template T\n */\n\nconst highSurrogateRegex = /[\\uD800-\\uDBFF]/\nconst lowSurrogateRegex = /[\\uDC00-\\uDFFF]/\n\n/**\n * Create a diff between two strings. This diff implementation is highly\n * efficient, but not very sophisticated.\n *\n * @function\n *\n * @param {string} a The old version of the string\n * @param {string} b The updated version of the string\n * @return {SimpleDiff<string>} The diff description.\n */\nexport const simpleDiffString = (a, b) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && a[left] === b[left]) {\n    left++\n  }\n  // If the last same character is a high surrogate, we need to rollback to the previous character\n  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--\n  while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {\n    right++\n  }\n  // If the last same character is a low surrogate, we need to rollback to the previous character\n  if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n\n/**\n * @todo Remove in favor of simpleDiffString\n * @deprecated\n */\nexport const simpleDiff = simpleDiffString\n\n/**\n * Create a diff between two arrays. This diff implementation is highly\n * efficient, but not very sophisticated.\n *\n * Note: This is basically the same function as above. Another function was created so that the runtime\n * can better optimize these function calls.\n *\n * @function\n * @template T\n *\n * @param {Array<T>} a The old version of the array\n * @param {Array<T>} b The updated version of the array\n * @param {function(T, T):boolean} [compare]\n * @return {SimpleDiff<Array<T>>} The diff description.\n */\nexport const simpleDiffArray = (a, b, compare = equalityStrict) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && compare(a[left], b[left])) {\n    left++\n  }\n  while (right + left < a.length && right + left < b.length && compare(a[a.length - right - 1], b[b.length - right - 1])) {\n    right++\n  }\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n\n/**\n * Diff text and try to diff at the current cursor position.\n *\n * @param {string} a\n * @param {string} b\n * @param {number} cursor This should refer to the current left cursor-range position\n */\nexport const simpleDiffStringWithCursor = (a, b, cursor) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  // Iterate left to the right until we find a changed character\n  // First iteration considers the current cursor position\n  while (\n    left < a.length &&\n    left < b.length &&\n    a[left] === b[left] &&\n    left < cursor\n  ) {\n    left++\n  }\n  // If the last same character is a high surrogate, we need to rollback to the previous character\n  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--\n  // Iterate right to the left until we find a changed character\n  while (\n    right + left < a.length &&\n    right + left < b.length &&\n    a[a.length - right - 1] === b[b.length - right - 1]\n  ) {\n    right++\n  }\n  // If the last same character is a low surrogate, we need to rollback to the previous character\n  if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--\n  // Try to iterate left further to the right without caring about the current cursor position\n  while (\n    right + left < a.length &&\n    right + left < b.length &&\n    a[left] === b[left]\n  ) {\n    left++\n  }\n  if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n", "import { PluginKey } from 'prosemirror-state' // eslint-disable-line\n\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */\nexport const ySyncPluginKey = new PluginKey('y-sync')\n\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n */\nexport const yUndoPluginKey = new PluginKey('y-undo')\n\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */\nexport const yCursorPluginKey = new PluginKey('yjs-cursor')\n", "/**\n * @module bindings/prosemirror\n */\n\nimport { createMutex } from 'lib0/mutex'\nimport * as PModel from 'prosemirror-model'\nimport { Plugin, TextSelection } from \"prosemirror-state\"; // eslint-disable-line\nimport * as math from 'lib0/math'\nimport * as object from 'lib0/object'\nimport * as set from 'lib0/set'\nimport { simpleDiff } from 'lib0/diff'\nimport * as error from 'lib0/error'\nimport { ySyncPluginKey, yUndoPluginKey } from './keys.js'\nimport * as Y from 'yjs'\nimport {\n  absolutePositionToRelativePosition,\n  relativePositionToAbsolutePosition\n} from '../lib.js'\nimport * as random from 'lib0/random'\nimport * as environment from 'lib0/environment'\nimport * as dom from 'lib0/dom'\nimport * as eventloop from 'lib0/eventloop'\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\nexport const isVisible = (item, snapshot) =>\n  snapshot === undefined\n    ? !item.deleted\n    : (snapshot.sv.has(item.id.client) && /** @type {number} */\n      (snapshot.sv.get(item.id.client)) > item.id.clock &&\n      !Y.isDeleted(snapshot.ds, item.id))\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {ProsemirrorMapping} [YSyncOpts.mapping]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */\n\n/**\n * @type {Array<ColorDef>}\n */\nconst defaultColors = [{ light: '#ecd44433', dark: '#ecd444' }]\n\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = set.create()\n      colorMapping.forEach((color) => usedColors.add(color))\n      colors = colors.filter((color) => !usedColors.has(color))\n    }\n    colorMapping.set(user, random.oneOf(colors))\n  }\n  return /** @type {ColorDef} */ (colorMapping.get(user))\n}\n\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\nexport const ySyncPlugin = (yXmlFragment, {\n  colors = defaultColors,\n  colorMapping = new Map(),\n  permanentUserData = null,\n  onFirstRender = () => {},\n  mapping\n} = {}) => {\n  let initialContentChanged = false\n  const binding = new ProsemirrorBinding(yXmlFragment, mapping)\n  const plugin = new Plugin({\n    props: {\n      editable: (state) => {\n        const syncState = ySyncPluginKey.getState(state)\n        return syncState.snapshot == null && syncState.prevSnapshot == null\n      }\n    },\n    key: ySyncPluginKey,\n    state: {\n      /**\n       * @returns {any}\n       */\n      init: (_initargs, _state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          isUndoRedoOperation: false,\n          addToHistory: true,\n          colors,\n          colorMapping,\n          permanentUserData\n        }\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(ySyncPluginKey)\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState)\n          for (const key in change) {\n            pluginState[key] = change[key]\n          }\n        }\n        pluginState.addToHistory = tr.getMeta('addToHistory') !== false\n        // always set isChangeOrigin. If undefined, this is not change origin.\n        pluginState.isChangeOrigin = change !== undefined &&\n          !!change.isChangeOrigin\n        pluginState.isUndoRedoOperation = change !== undefined && !!change.isChangeOrigin && !!change.isUndoRedoOperation\n        if (binding.prosemirrorView !== null) {\n          if (\n            change !== undefined &&\n            (change.snapshot != null || change.prevSnapshot != null)\n          ) {\n            // snapshot changed, rerender next\n            eventloop.timeout(0, () => {\n              if (binding.prosemirrorView == null) {\n                return\n              }\n              if (change.restore == null) {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.prevSnapshot,\n                  pluginState\n                )\n              } else {\n                binding._renderSnapshot(\n                  change.snapshot,\n                  change.snapshot,\n                  pluginState\n                )\n                // reset to current prosemirror state\n                delete pluginState.restore\n                delete pluginState.snapshot\n                delete pluginState.prevSnapshot\n                binding.mux(() => {\n                  binding._prosemirrorChanged(\n                    binding.prosemirrorView.state.doc\n                  )\n                })\n              }\n            })\n          }\n        }\n        return pluginState\n      }\n    },\n    view: (view) => {\n      binding.initView(view)\n      if (mapping == null) {\n        // force rerender to update the bindings mapping\n        binding._forceRerender()\n      }\n      onFirstRender()\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state)\n          if (\n            pluginState.snapshot == null && pluginState.prevSnapshot == null\n          ) {\n            if (\n              // If the content doesn't change initially, we don't render anything to Yjs\n              // If the content was cleared by a user action, we want to catch the change and\n              // represent it in Yjs\n              initialContentChanged ||\n              view.state.doc.content.findDiffStart(\n                view.state.doc.type.createAndFill().content\n              ) !== null\n            ) {\n              initialContentChanged = true\n              if (\n                pluginState.addToHistory === false &&\n                !pluginState.isChangeOrigin\n              ) {\n                const yUndoPluginState = yUndoPluginKey.getState(view.state)\n                /**\n                 * @type {Y.UndoManager}\n                 */\n                const um = yUndoPluginState && yUndoPluginState.undoManager\n                if (um) {\n                  um.stopCapturing()\n                }\n              }\n              binding.mux(() => {\n                /** @type {Y.Doc} */ (pluginState.doc).transact((tr) => {\n                  tr.meta.set('addToHistory', pluginState.addToHistory)\n                  binding._prosemirrorChanged(view.state.doc)\n                }, ySyncPluginKey)\n              })\n            }\n          }\n        },\n        destroy: () => {\n          binding.destroy()\n        }\n      }\n    }\n  })\n  return plugin\n}\n\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    const anchor = relativePositionToAbsolutePosition(\n      binding.doc,\n      binding.type,\n      relSel.anchor,\n      binding.mapping\n    )\n    const head = relativePositionToAbsolutePosition(\n      binding.doc,\n      binding.type,\n      relSel.head,\n      binding.mapping\n    )\n    if (anchor !== null && head !== null) {\n      tr = tr.setSelection(TextSelection.create(tr.doc, anchor, head))\n    }\n  }\n}\n\nexport const getRelativeSelection = (pmbinding, state) => ({\n  anchor: absolutePositionToRelativePosition(\n    state.selection.anchor,\n    pmbinding.type,\n    pmbinding.mapping\n  ),\n  head: absolutePositionToRelativePosition(\n    state.selection.head,\n    pmbinding.type,\n    pmbinding.mapping\n  )\n})\n\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\nexport class ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {ProsemirrorMapping} mapping\n   */\n  constructor (yXmlFragment, mapping = new Map()) {\n    this.type = yXmlFragment\n    /**\n     * this will be set once the view is created\n     * @type {any}\n     */\n    this.prosemirrorView = null\n    this.mux = createMutex()\n    this.mapping = mapping\n    this._observeFunction = this._typeChanged.bind(this)\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n    this.doc = yXmlFragment.doc\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n    this.beforeTransactionSelection = null\n    this.beforeAllTransactions = () => {\n      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {\n        this.beforeTransactionSelection = getRelativeSelection(\n          this,\n          this.prosemirrorView.state\n        )\n      }\n    }\n    this.afterAllTransactions = () => {\n      this.beforeTransactionSelection = null\n    }\n    this._domSelectionInView = null\n  }\n\n  /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */\n  get _tr () {\n    return this.prosemirrorView.state.tr.setMeta('addToHistory', false)\n  }\n\n  _isLocalCursorInView () {\n    if (!this.prosemirrorView.hasFocus()) return false\n    if (environment.isBrowser && this._domSelectionInView === null) {\n      // Calculate the domSelectionInView and clear by next tick after all events are finished\n      eventloop.timeout(0, () => {\n        this._domSelectionInView = null\n      })\n      this._domSelectionInView = this._isDomSelectionInView()\n    }\n    return this._domSelectionInView\n  }\n\n  _isDomSelectionInView () {\n    const selection = this.prosemirrorView._root.getSelection()\n\n    const range = this.prosemirrorView._root.createRange()\n    range.setStart(selection.anchorNode, selection.anchorOffset)\n    range.setEnd(selection.focusNode, selection.focusOffset)\n\n    // This is a workaround for an edgecase where getBoundingClientRect will\n    // return zero values if the selection is collapsed at the start of a newline\n    // see reference here: https://stackoverflow.com/a/59780954\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      // probably buggy newline behavior, explicitly select the node contents\n      if (range.startContainer && range.collapsed) {\n        range.selectNodeContents(range.startContainer)\n      }\n    }\n\n    const bounding = range.getBoundingClientRect()\n    const documentElement = dom.doc.documentElement\n\n    return bounding.bottom >= 0 && bounding.right >= 0 &&\n      bounding.left <=\n        (window.innerWidth || documentElement.clientWidth || 0) &&\n      bounding.top <= (window.innerHeight || documentElement.clientHeight || 0)\n  }\n\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   */\n  renderSnapshot (snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = Y.createSnapshot(Y.createDeleteSet(), new Map())\n    }\n    this.prosemirrorView.dispatch(\n      this._tr.setMeta(ySyncPluginKey, { snapshot, prevSnapshot })\n    )\n  }\n\n  unrenderSnapshot () {\n    this.mapping.clear()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this.mapping\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new PModel.Slice(PModel.Fragment.from(fragmentContent), 0, 0)\n      )\n      tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null })\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _forceRerender () {\n    this.mapping.clear()\n    this.mux(() => {\n      // If this is a forced rerender, this might neither happen as a pm change nor within a Yjs\n      // transaction. Then the \"before selection\" doesn't exist. In this case, we need to create a\n      // relative position before replacing content. Fixes #126\n      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeFromYElement(\n          /** @type {Y.XmlElement} */ (t),\n          this.prosemirrorView.state.schema,\n          this.mapping\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new PModel.Slice(PModel.Fragment.from(fragmentContent), 0, 0)\n      )\n      if (sel) {\n        tr.setSelection(TextSelection.create(tr.doc, sel.anchor, sel.head))\n      }\n      this.prosemirrorView.dispatch(\n        tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })\n      )\n    })\n  }\n\n  /**\n   * @param {Y.Snapshot|Uint8Array} snapshot\n   * @param {Y.Snapshot|Uint8Array} prevSnapshot\n   * @param {Object} pluginState\n   */\n  _renderSnapshot (snapshot, prevSnapshot, pluginState) {\n    /**\n     * The document that contains the full history of this document.\n     * @type {Y.Doc}\n     */\n    let historyDoc = this.doc\n    if (!snapshot) {\n      snapshot = Y.snapshot(this.doc)\n    }\n    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {\n      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {\n        // expected both snapshots to be v2 updates\n        error.unexpectedCase()\n      }\n      historyDoc = new Y.Doc({ gc: false })\n      Y.applyUpdateV2(historyDoc, prevSnapshot)\n      prevSnapshot = Y.snapshot(historyDoc)\n      Y.applyUpdateV2(historyDoc, snapshot)\n      snapshot = Y.snapshot(historyDoc)\n    }\n    // clear mapping because we are going to rerender\n    this.mapping.clear()\n    this.mux(() => {\n      historyDoc.transact((transaction) => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        const pud = pluginState.permanentUserData\n        if (pud) {\n          pud.dss.forEach((ds) => {\n            Y.iterateDeletedStructs(transaction, ds, (_item) => {})\n          })\n        }\n        /**\n         * @param {'removed'|'added'} type\n         * @param {Y.ID} id\n         */\n        const computeYChange = (type, id) => {\n          const user = type === 'added'\n            ? pud.getUserByClientId(id.client)\n            : pud.getUserByDeletedId(id)\n          return {\n            user,\n            type,\n            color: getUserColor(\n              pluginState.colorMapping,\n              pluginState.colors,\n              user\n            )\n          }\n        }\n        // Create document fragment and render\n        const fragmentContent = Y.typeListToArraySnapshot(\n          this.type,\n          new Y.Snapshot(prevSnapshot.ds, snapshot.sv)\n        ).map((t) => {\n          if (\n            !t._item.deleted || isVisible(t._item, snapshot) ||\n            isVisible(t._item, prevSnapshot)\n          ) {\n            return createNodeFromYElement(\n              t,\n              this.prosemirrorView.state.schema,\n              new Map(),\n              snapshot,\n              prevSnapshot,\n              computeYChange\n            )\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null\n          }\n        }).filter((n) => n !== null)\n        // @ts-ignore\n        const tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new PModel.Slice(PModel.Fragment.from(fragmentContent), 0, 0)\n        )\n        this.prosemirrorView.dispatch(\n          tr.setMeta(ySyncPluginKey, { isChangeOrigin: true })\n        )\n      }, ySyncPluginKey)\n    })\n  }\n\n  /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */\n  _typeChanged (events, transaction) {\n    if (this.prosemirrorView == null) return\n    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state)\n    if (\n      events.length === 0 || syncState.snapshot != null ||\n      syncState.prevSnapshot != null\n    ) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot)\n      return\n    }\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */\n      const delType = (_, type) => this.mapping.delete(type)\n      Y.iterateDeletedStructs(\n        transaction,\n        transaction.deleteSet,\n        (struct) => {\n          if (struct.constructor === Y.Item) {\n            const type = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (struct).content).type\n            type && this.mapping.delete(type)\n          }\n        }\n      )\n      transaction.changed.forEach(delType)\n      transaction.changedParentTypes.forEach(delType)\n      const fragmentContent = this.type.toArray().map((t) =>\n        createNodeIfNotExists(\n          /** @type {Y.XmlElement | Y.XmlHook} */ (t),\n          this.prosemirrorView.state.schema,\n          this.mapping\n        )\n      ).filter((n) => n !== null)\n      // @ts-ignore\n      let tr = this._tr.replace(\n        0,\n        this.prosemirrorView.state.doc.content.size,\n        new PModel.Slice(PModel.Fragment.from(fragmentContent), 0, 0)\n      )\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this)\n      tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof Y.UndoManager })\n      if (\n        this.beforeTransactionSelection !== null && this._isLocalCursorInView()\n      ) {\n        tr.scrollIntoView()\n      }\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _prosemirrorChanged (doc) {\n    this.doc.transact(() => {\n      updateYFragment(this.doc, this.type, doc, this.mapping)\n      this.beforeTransactionSelection = getRelativeSelection(\n        this,\n        this.prosemirrorView.state\n      )\n    }, ySyncPluginKey)\n  }\n\n  /**\n   * View is ready to listen to changes. Register observers.\n   * @param {any} prosemirrorView\n   */\n  initView (prosemirrorView) {\n    if (this.prosemirrorView != null) this.destroy()\n    this.prosemirrorView = prosemirrorView\n    this.doc.on('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.on('afterAllTransactions', this.afterAllTransactions)\n    this.type.observeDeep(this._observeFunction)\n  }\n\n  destroy () {\n    if (this.prosemirrorView == null) return\n    this.prosemirrorView = null\n    this.type.unobserveDeep(this._observeFunction)\n    this.doc.off('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.off('afterAllTransactions', this.afterAllTransactions)\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\nconst createNodeIfNotExists = (\n  el,\n  schema,\n  mapping,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const node = /** @type {PModel.Node} */ (mapping.get(el))\n  if (node === undefined) {\n    if (el instanceof Y.XmlElement) {\n      return createNodeFromYElement(\n        el,\n        schema,\n        mapping,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n    } else {\n      throw error.methodUnimplemented() // we are currently not handling hooks\n    }\n  }\n  return node\n}\n\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\nexport const createNodeFromYElement = (\n  el,\n  schema,\n  mapping,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const children = []\n  const createChildren = (type) => {\n    if (type.constructor === Y.XmlElement) {\n      const n = createNodeIfNotExists(\n        type,\n        schema,\n        mapping,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (n !== null) {\n        children.push(n)\n      }\n    } else {\n      const ns = createTextNodesFromYText(\n        type,\n        schema,\n        mapping,\n        snapshot,\n        prevSnapshot,\n        computeYChange\n      )\n      if (ns !== null) {\n        ns.forEach((textchild) => {\n          if (textchild !== null) {\n            children.push(textchild)\n          }\n        })\n      }\n    }\n  }\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren)\n  } else {\n    Y.typeListToArraySnapshot(el, new Y.Snapshot(prevSnapshot.ds, snapshot.sv))\n      .forEach(createChildren)\n  }\n  try {\n    const attrs = el.getAttributes(snapshot)\n    if (snapshot !== undefined) {\n      if (!isVisible(/** @type {Y.Item} */ (el._item), snapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('removed', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'removed' }\n      } else if (!isVisible(/** @type {Y.Item} */ (el._item), prevSnapshot)) {\n        attrs.ychange = computeYChange\n          ? computeYChange('added', /** @type {Y.Item} */ (el._item).id)\n          : { type: 'added' }\n      }\n    }\n    const node = schema.node(el.nodeName, attrs, children)\n    mapping.set(el, node)\n    return node\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (el.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (el._item).delete(transaction)\n    }, ySyncPluginKey)\n    mapping.delete(el)\n    return null\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {any} schema\n * @param {ProsemirrorMapping} _mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\nconst createTextNodesFromYText = (\n  text,\n  schema,\n  _mapping,\n  snapshot,\n  prevSnapshot,\n  computeYChange\n) => {\n  const nodes = []\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange)\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i]\n      const marks = []\n      for (const markName in delta.attributes) {\n        marks.push(schema.mark(markName, delta.attributes[markName]))\n      }\n      nodes.push(schema.text(delta.insert, marks))\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (text.doc).transact((transaction) => {\n      /** @type {Y.Item} */ (text._item).delete(transaction)\n    }, ySyncPluginKey)\n    return null\n  }\n  // @ts-ignore\n  return nodes\n}\n\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlText}\n */\nconst createTypeFromTextNodes = (nodes, mapping) => {\n  const type = new Y.XmlText()\n  const delta = nodes.map((node) => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks)\n  }))\n  type.applyDelta(delta)\n  mapping.set(type, nodes)\n  return type\n}\n\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement}\n */\nconst createTypeFromElementNode = (node, mapping) => {\n  const type = new Y.XmlElement(node.type.name)\n  for (const key in node.attrs) {\n    const val = node.attrs[key]\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val)\n    }\n  }\n  type.insert(\n    0,\n    normalizePNodeContent(node).map((n) =>\n      createTypeFromTextOrElementNode(n, mapping)\n    )\n  )\n  mapping.set(type, node)\n  return type\n}\n\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement|Y.XmlText}\n */\nconst createTypeFromTextOrElementNode = (node, mapping) =>\n  node instanceof Array\n    ? createTypeFromTextNodes(node, mapping)\n    : createTypeFromElementNode(node, mapping)\n\nconst isObject = (val) => typeof val === 'object' && val !== null\n\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter((key) => pattrs[key] !== null)\n  let eq =\n    keys.length ===\n      Object.keys(yattrs).filter((key) => yattrs[key] !== null).length\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i]\n    const l = pattrs[key]\n    const r = yattrs[key]\n    eq = key === 'ychange' || l === r ||\n      (isObject(l) && isObject(r) && equalAttrs(l, r))\n  }\n  return eq\n}\n\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\nconst normalizePNodeContent = (pnode) => {\n  const c = pnode.content.content\n  const res = []\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i]\n    if (n.isText) {\n      const textNodes = []\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode)\n      }\n      i--\n      res.push(textNodes)\n    } else {\n      res.push(n)\n    }\n  }\n  return res\n}\n\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta()\n  return delta.length === ptexts.length &&\n    delta.every((d, i) =>\n      d.insert === /** @type {any} */ (ptexts[i]).text &&\n      object.keys(d.attributes || {}).length === ptexts[i].marks.length &&\n      ptexts[i].marks.every((mark) =>\n        equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)\n      )\n    )\n}\n\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\nconst equalYTypePNode = (ytype, pnode) => {\n  if (\n    ytype instanceof Y.XmlElement && !(pnode instanceof Array) &&\n    matchNodeName(ytype, pnode)\n  ) {\n    const normalizedContent = normalizePNodeContent(pnode)\n    return ytype._length === normalizedContent.length &&\n      equalAttrs(ytype.getAttributes(), pnode.attrs) &&\n      ytype.toArray().every((ychild, i) =>\n        equalYTypePNode(ychild, normalizedContent[i])\n      )\n  }\n  return ytype instanceof Y.XmlText && pnode instanceof Array &&\n    equalYTextPText(ytype, pnode)\n}\n\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\nconst mappedIdentity = (mapped, pcontent) =>\n  mapped === pcontent ||\n  (mapped instanceof Array && pcontent instanceof Array &&\n    mapped.length === pcontent.length && mapped.every((a, i) =>\n    pcontent[i] === a\n  ))\n\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {ProsemirrorMapping} mapping\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\nconst computeChildEqualityFactor = (ytype, pnode, mapping) => {\n  const yChildren = ytype.toArray()\n  const pChildren = normalizePNodeContent(pnode)\n  const pChildCnt = pChildren.length\n  const yChildCnt = yChildren.length\n  const minCnt = math.min(yChildCnt, pChildCnt)\n  let left = 0\n  let right = 0\n  let foundMappedChild = false\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (mappedIdentity(mapping.get(leftY), leftP)) {\n      foundMappedChild = true // definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break\n    }\n  }\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (mappedIdentity(mapping.get(rightY), rightP)) {\n      foundMappedChild = true\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break\n    }\n  }\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  }\n}\n\nconst ytextTrans = (ytext) => {\n  let str = ''\n  /**\n   * @type {Y.Item|null}\n   */\n  let n = ytext._start\n  const nAttrs = {}\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof Y.ContentString) {\n        str += n.content.str\n      } else if (n.content instanceof Y.ContentFormat) {\n        nAttrs[n.content.key] = null\n      }\n    }\n    n = n.right\n  }\n  return {\n    str,\n    nAttrs\n  }\n}\n\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYText = (ytext, ptexts, mapping) => {\n  mapping.set(ytext, ptexts)\n  const { nAttrs, str } = ytextTrans(ytext)\n  const content = ptexts.map((p) => ({\n    insert: /** @type {any} */ (p).text,\n    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks))\n  }))\n  const { insert, remove, index } = simpleDiff(\n    str,\n    content.map((c) => c.insert).join('')\n  )\n  ytext.delete(index, remove)\n  ytext.insert(index, insert)\n  ytext.applyDelta(\n    content.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))\n  )\n}\n\nconst marksToAttributes = (marks) => {\n  const pattrs = {}\n  marks.forEach((mark) => {\n    if (mark.type.name !== 'ychange') {\n      pattrs[mark.type.name] = mark.attrs\n    }\n  })\n  return pattrs\n}\n\n/**\n * Update a yDom node by syncing the current content of the prosemirror node.\n *\n * This is a y-prosemirror internal feature that you can use at your own risk.\n *\n * @private\n * @unstable\n *\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {ProsemirrorMapping} mapping\n */\nexport const updateYFragment = (y, yDomFragment, pNode, mapping) => {\n  if (\n    yDomFragment instanceof Y.XmlElement &&\n    yDomFragment.nodeName !== pNode.type.name\n  ) {\n    throw new Error('node name mismatch!')\n  }\n  mapping.set(yDomFragment, pNode)\n  // update attributes\n  if (yDomFragment instanceof Y.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes()\n    const pAttrs = pNode.attrs\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key])\n        }\n      } else {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n    // remove all keys that are no longer in pAttrs\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n  }\n  // update children\n  const pChildren = normalizePNodeContent(pNode)\n  const pChildCnt = pChildren.length\n  const yChildren = yDomFragment.toArray()\n  const yChildCnt = yChildren.length\n  const minCnt = math.min(pChildCnt, yChildCnt)\n  let left = 0\n  let right = 0\n  // find number of matching elements from left\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (!mappedIdentity(mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        mapping.set(leftY, leftP)\n      } else {\n        break\n      }\n    }\n  }\n  // find number of matching elements from right\n  for (; right + left + 1 < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (!mappedIdentity(mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        mapping.set(rightY, rightP)\n      } else {\n        break\n      }\n    }\n  }\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left]\n      const leftP = pChildren[left]\n      const rightY = yChildren[yChildCnt - right - 1]\n      const rightP = pChildren[pChildCnt - right - 1]\n      if (leftY instanceof Y.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, mapping)\n        }\n        left += 1\n      } else {\n        let updateLeft = leftY instanceof Y.XmlElement &&\n          matchNodeName(leftY, leftP)\n        let updateRight = rightY instanceof Y.XmlElement &&\n          matchNodeName(rightY, rightP)\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            mapping\n          )\n          const equalityRight = computeChildEqualityFactor(\n            /** @type {Y.XmlElement} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            mapping\n          )\n          if (\n            equalityLeft.foundMappedChild && !equalityRight.foundMappedChild\n          ) {\n            updateRight = false\n          } else if (\n            !equalityLeft.foundMappedChild && equalityRight.foundMappedChild\n          ) {\n            updateLeft = false\n          } else if (\n            equalityLeft.equalityFactor < equalityRight.equalityFactor\n          ) {\n            updateLeft = false\n          } else {\n            updateRight = false\n          }\n        }\n        if (updateLeft) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (leftY),\n            /** @type {PModel.Node} */ (leftP),\n            mapping\n          )\n          left += 1\n        } else if (updateRight) {\n          updateYFragment(\n            y,\n            /** @type {Y.XmlFragment} */ (rightY),\n            /** @type {PModel.Node} */ (rightP),\n            mapping\n          )\n          right += 1\n        } else {\n          mapping.delete(yDomFragment.get(left))\n          yDomFragment.delete(left, 1)\n          yDomFragment.insert(left, [\n            createTypeFromTextOrElementNode(leftP, mapping)\n          ])\n          left += 1\n        }\n      }\n    }\n    const yDelLen = yChildCnt - left - right\n    if (\n      yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof Y.XmlText\n    ) {\n      mapping.delete(yChildren[0])\n      // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n      // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n      yChildren[0].delete(0, yChildren[0].length)\n    } else if (yDelLen > 0) {\n      yDomFragment.slice(left, left + yDelLen).forEach(type => mapping.delete(type))\n      yDomFragment.delete(left, yDelLen)\n    }\n    if (left + right < pChildCnt) {\n      const ins = []\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping))\n      }\n      yDomFragment.insert(left, ins)\n    }\n  }, ySyncPluginKey)\n}\n\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\nconst matchNodeName = (yElement, pNode) =>\n  !(pNode instanceof Array) && yElement.nodeName === pNode.type.name\n", "import { updateYFragment, createNodeFromYElement } from './plugins/sync-plugin.js' // eslint-disable-line\nimport { ySyncPluginKey } from './plugins/keys.js'\nimport * as Y from 'yjs'\nimport { EditorView } from 'prosemirror-view' // eslint-disable-line\nimport { Node, Schema, Fragment } from 'prosemirror-model' // eslint-disable-line\nimport * as error from 'lib0/error'\nimport * as map from 'lib0/map'\nimport * as eventloop from 'lib0/eventloop'\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */\n\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\nlet viewsToUpdate = null\n\nconst updateMetas = () => {\n  const ups = /** @type {Map<EditorView, Map<any, any>>} */ (viewsToUpdate)\n  viewsToUpdate = null\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr\n    const syncState = ySyncPluginKey.getState(view.state)\n    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n      metas.forEach((val, key) => {\n        tr.setMeta(key, val)\n      })\n      view.dispatch(tr)\n    }\n  })\n}\n\nexport const setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map()\n    eventloop.timeout(0, updateMetas)\n  }\n  map.setIfUndefined(viewsToUpdate, view, map.create).set(key, value)\n}\n\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\nexport const absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    return Y.createRelativePositionFromTypeIndex(type, 0, -1)\n  }\n  /**\n   * @type {any}\n   */\n  let n = type._first === null ? null : /** @type {Y.ContentType} */ (type._first.content).type\n  while (n !== null && type !== n) {\n    if (n instanceof Y.XmlText) {\n      if (n._length >= pos) {\n        return Y.createRelativePositionFromTypeIndex(n, pos, -1)\n      } else {\n        pos -= n._length\n      }\n      if (n._item !== null && n._item.next !== null) {\n        n = /** @type {Y.ContentType} */ (n._item.next.content).type\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent\n          pos--\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null)\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null : /** @type {Y.ContentType} */ (/** @type Y.Item */ (n._item.next).content).type\n        }\n      }\n    } else {\n      const pNodeSize = /** @type {any} */ (mapping.get(n) || { nodeSize: 0 }).nodeSize\n      if (n._first !== null && pos < pNodeSize) {\n        n = /** @type {Y.ContentType} */ (n._first.content).type\n        pos--\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null)\n        }\n        pos -= pNodeSize\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */ (n._item.next.content).type\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent\n            return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null)\n          }\n          do {\n            n = /** @type {Y.Item} */ (n._item).parent\n            pos--\n          } while (n !== type && /** @type {Y.Item} */ (n._item).next === null)\n          // if n is null at this point, we have an unexpected case\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (/** @type {Y.Item} */ (n._item).next).content).type\n          }\n        }\n      }\n    }\n    if (n === null) {\n      throw error.unexpectedCase()\n    }\n    if (pos === 0 && n.constructor !== Y.XmlText && n !== type) { // TODO: set to <= 0\n      return createRelativePosition(n._item.parent, n._item)\n    }\n  }\n  return Y.createRelativePositionFromTypeIndex(type, type._length, -1)\n}\n\nconst createRelativePosition = (type, item) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = Y.findRootTypeKey(type)\n  } else {\n    typeid = Y.createID(type._item.id.client, type._item.id.clock)\n  }\n  return new Y.RelativePosition(typeid, tname, item.id)\n}\n\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */\nexport const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = Y.createAbsolutePositionFromRelativePosition(relPos, y)\n  if (decodedPos === null || (decodedPos.type !== documentType && !Y.isParentOf(documentType, decodedPos.type._item))) {\n    return null\n  }\n  let type = decodedPos.type\n  let pos = 0\n  if (type.constructor === Y.XmlText) {\n    pos = decodedPos.index\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first\n    let i = 0\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t = /** @type {Y.ContentType} */ (n.content).type\n        i++\n        if (t instanceof Y.XmlText) {\n          pos += t._length\n        } else {\n          pos += /** @type {any} */ (mapping.get(t)).nodeSize\n        }\n      }\n      n = /** @type {Y.Item} */ (n.right)\n    }\n    pos += 1 // increase because we go out of n\n  }\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent\n    // @ts-ignore\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1 // the start tag\n      let n = /** @type {Y.AbstractType} */ (parent)._first\n      // now iterate until we found type\n      while (n !== null) {\n        const contentType = /** @type {Y.ContentType} */ (n.content).type\n        if (contentType === type) {\n          break\n        }\n        if (!n.deleted) {\n          if (contentType instanceof Y.XmlText) {\n            pos += contentType._length\n          } else {\n            pos += /** @type {any} */ (mapping.get(contentType)).nodeSize\n          }\n        }\n        n = n.right\n      }\n    }\n    type = /** @type {Y.AbstractType} */ (parent)\n  }\n  return pos - 1 // we don't count the most outer tag, because it is a fragment\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror fragment.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nexport const yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    createNodeFromYElement(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      new Map()\n    )\n  ).filter((n) => n !== null)\n  return Fragment.fromArray(fragmentContent)\n}\n\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror node.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nexport const yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) =>\n  schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema))\n\n/**\n * The initial ProseMirror content should be supplied by Yjs. This function transforms a Y.Fragment\n * to a ProseMirror Doc node and creates a mapping that is used by the sync plugin.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */\nexport const initProseMirrorDoc = (yXmlFragment, schema) => {\n  /**\n   * @type {ProsemirrorMapping}\n   */\n  const mapping = new Map()\n  const fragmentContent = yXmlFragment.toArray().map((t) =>\n    createNodeFromYElement(\n      /** @type {Y.XmlElement} */ (t),\n      schema,\n      mapping\n    )\n  ).filter((n) => n !== null)\n  const doc = schema.topNodeType.create(null, Fragment.fromArray(fragmentContent))\n  return { doc, mapping }\n}\n\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nexport function prosemirrorToYDoc (doc, xmlFragment = 'prosemirror') {\n  const ydoc = new Y.Doc()\n  const type = /** @type {Y.XmlFragment} */ (ydoc.get(xmlFragment, Y.XmlFragment))\n  if (!type.doc) {\n    return ydoc\n  }\n\n  prosemirrorToYXmlFragment(doc, type)\n  return type.doc\n}\n\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nexport function prosemirrorToYXmlFragment (doc, xmlFragment) {\n  const type = xmlFragment || new Y.XmlFragment()\n  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(undefined) }\n  updateYFragment(ydoc, type, doc, new Map())\n  return type\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nexport function prosemirrorJSONToYDoc (schema, state, xmlFragment = 'prosemirror') {\n  const doc = Node.fromJSON(schema, state)\n  return prosemirrorToYDoc(doc, xmlFragment)\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nexport function prosemirrorJSONToYXmlFragment (schema, state, xmlFragment) {\n  const doc = Node.fromJSON(schema, state)\n  return prosemirrorToYXmlFragment(doc, xmlFragment)\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorNode` instead\n *\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */\nexport function yDocToProsemirror (schema, ydoc) {\n  const state = yDocToProsemirrorJSON(ydoc)\n  return Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorNode` instead\n *\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */\nexport function yXmlFragmentToProsemirror (schema, xmlFragment) {\n  const state = yXmlFragmentToProsemirrorJSON(xmlFragment)\n  return Node.fromJSON(schema, state)\n}\n\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */\nexport function yDocToProsemirrorJSON (\n  ydoc,\n  xmlFragment = 'prosemirror'\n) {\n  return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment))\n}\n\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */\nexport function yXmlFragmentToProsemirrorJSON (xmlFragment) {\n  const items = xmlFragment.toArray()\n\n  function serialize (item) {\n    /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */\n    let response\n\n    // TODO: Must be a better way to detect text nodes than this\n    if (!item.nodeName) {\n      const delta = item.toDelta()\n      response = delta.map((d) => {\n        const text = {\n          type: 'text',\n          text: d.insert\n        }\n\n        if (d.attributes) {\n          text.marks = Object.keys(d.attributes).map((type) => {\n            const attrs = d.attributes[type]\n            const mark = {\n              type\n            }\n\n            if (Object.keys(attrs)) {\n              mark.attrs = attrs\n            }\n\n            return mark\n          })\n        }\n        return text\n      })\n    } else {\n      response = {\n        type: item.nodeName\n      }\n\n      const attrs = item.getAttributes()\n      if (Object.keys(attrs).length) {\n        response.attrs = attrs\n      }\n\n      const children = item.toArray()\n      if (children.length) {\n        response.content = children.map(serialize).flat()\n      }\n    }\n\n    return response\n  }\n\n  return {\n    type: 'doc',\n    content: items.map(serialize)\n  }\n}\n", "import { Plugin } from 'prosemirror-state' // eslint-disable-line\n\nimport { getRelativeSelection } from './sync-plugin.js'\nimport { UndoManager, Item, ContentType, XmlElement, Text } from 'yjs'\nimport { yUndoPluginKey, ySyncPluginKey } from './keys.js'\n\nexport const undo = state => {\n  const undoManager = yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.undo()\n    return true\n  }\n}\n\nexport const redo = state => {\n  const undoManager = yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.redo()\n    return true\n  }\n}\n\nexport const defaultProtectedNodes = new Set(['paragraph'])\n\nexport const defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Item) ||\n!(item.content instanceof ContentType) ||\n!(item.content.type instanceof Text ||\n  (item.content.type instanceof XmlElement && protectedNodes.has(item.content.type.nodeName))) ||\nitem.content.type._length === 0\n\nexport const yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({\n  key: yUndoPluginKey,\n  state: {\n    init: (initargs, state) => {\n      // TODO: check if plugin order matches and fix\n      const ystate = ySyncPluginKey.getState(state)\n      const _undoManager = undoManager || new UndoManager(ystate.type, {\n        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),\n        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),\n        captureTransaction: tr => tr.meta.get('addToHistory') !== false\n      })\n      return {\n        undoManager: _undoManager,\n        prevSel: null,\n        hasUndoOps: _undoManager.undoStack.length > 0,\n        hasRedoOps: _undoManager.redoStack.length > 0\n      }\n    },\n    /**\n     * @returns {any}\n     */\n    apply: (tr, val, oldState, state) => {\n      const binding = ySyncPluginKey.getState(state).binding\n      const undoManager = val.undoManager\n      const hasUndoOps = undoManager.undoStack.length > 0\n      const hasRedoOps = undoManager.redoStack.length > 0\n      if (binding) {\n        return {\n          undoManager,\n          prevSel: getRelativeSelection(binding, oldState),\n          hasUndoOps,\n          hasRedoOps\n        }\n      } else {\n        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n          return Object.assign({}, val, {\n            hasUndoOps: undoManager.undoStack.length > 0,\n            hasRedoOps: undoManager.redoStack.length > 0\n          })\n        } else { // nothing changed\n          return val\n        }\n      }\n    }\n  },\n  view: view => {\n    const ystate = ySyncPluginKey.getState(view.state)\n    const undoManager = yUndoPluginKey.getState(view.state).undoManager\n    undoManager.on('stack-item-added', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel)\n      }\n    })\n    undoManager.on('stack-item-popped', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection\n      }\n    })\n    return {\n      destroy: () => {\n        undoManager.destroy()\n      }\n    }\n  }\n})\n", "import { Extension } from '@tiptap/core'\nimport { EditorView } from '@tiptap/pm/view'\nimport {\n  redo,\n  undo,\n  ySyncPlugin,\n  yUndoPlugin,\n  yUndoPluginKey,\n} from 'y-prosemirror'\nimport { UndoManager } from 'yjs'\n\ntype YSyncOpts = Parameters<typeof ySyncPlugin>[1]\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    collaboration: {\n      /**\n       * Undo recent changes\n       * @example editor.commands.undo()\n       */\n      undo: () => ReturnType,\n      /**\n       * Reapply reverted changes\n       * @example editor.commands.redo()\n       */\n      redo: () => ReturnType,\n    }\n  }\n}\n\nexport interface CollaborationOptions {\n  /**\n   * An initialized Y.js document.\n   * @example new Y.Doc()\n   */\n  document: any,\n\n  /**\n   * Name of a Y.js fragment, can be changed to sync multiple fields with one Y.js document.\n   * @default 'default'\n   * @example 'my-custom-field'\n   */\n  field: string,\n\n  /**\n   * A raw Y.js fragment, can be used instead of `document` and `field`.\n   * @example new Y.Doc().getXmlFragment('body')\n   */\n  fragment: any,\n\n  /**\n   * Fired when the content from Yjs is initially rendered to Tiptap.\n   */\n  onFirstRender?: () => void,\n\n  ySyncOptions?: YSyncOpts\n}\n\n/**\n * This extension allows you to collaborate with others in real-time.\n * @see https://tiptap.dev/api/extensions/collaboration\n */\nexport const Collaboration = Extension.create<CollaborationOptions>({\n  name: 'collaboration',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      document: null,\n      field: 'default',\n      fragment: null,\n    }\n  },\n\n  onCreate() {\n    if (this.editor.extensionManager.extensions.find(extension => extension.name === 'history')) {\n      console.warn('[tiptap warn]: \"@tiptap/extension-collaboration\" comes with its own history support and is not compatible with \"@tiptap/extension-history\".')\n    }\n  },\n\n  addCommands() {\n    return {\n      undo: () => ({ tr, state, dispatch }) => {\n        tr.setMeta('preventDispatch', true)\n\n        const undoManager: UndoManager = yUndoPluginKey.getState(state).undoManager\n\n        if (undoManager.undoStack.length === 0) {\n          return false\n        }\n\n        if (!dispatch) {\n          return true\n        }\n\n        return undo(state)\n      },\n      redo: () => ({ tr, state, dispatch }) => {\n        tr.setMeta('preventDispatch', true)\n\n        const undoManager: UndoManager = yUndoPluginKey.getState(state).undoManager\n\n        if (undoManager.redoStack.length === 0) {\n          return false\n        }\n\n        if (!dispatch) {\n          return true\n        }\n\n        return redo(state)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Mod-y': () => this.editor.commands.redo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const fragment = this.options.fragment\n      ? this.options.fragment\n      : this.options.document.getXmlFragment(this.options.field)\n\n    // Quick fix until there is an official implementation (thanks to @hamflx).\n    // See https://github.com/yjs/y-prosemirror/issues/114 and https://github.com/yjs/y-prosemirror/issues/102\n    const yUndoPluginInstance = yUndoPlugin()\n    const originalUndoPluginView = yUndoPluginInstance.spec.view\n\n    yUndoPluginInstance.spec.view = (view: EditorView) => {\n      const { undoManager } = yUndoPluginKey.getState(view.state)\n\n      if (undoManager.restore) {\n        undoManager.restore()\n        // eslint-disable-next-line\n        undoManager.restore = () => {}\n      }\n\n      const viewRet = originalUndoPluginView ? originalUndoPluginView(view) : undefined\n\n      return {\n        destroy: () => {\n          const hasUndoManSelf = undoManager.trackedOrigins.has(undoManager)\n          // eslint-disable-next-line\n          const observers = undoManager._observers\n\n          undoManager.restore = () => {\n            if (hasUndoManSelf) {\n              undoManager.trackedOrigins.add(undoManager)\n            }\n\n            undoManager.doc.on('afterTransaction', undoManager.afterTransactionHandler)\n            // eslint-disable-next-line\n            undoManager._observers = observers\n          }\n\n          if (viewRet?.destroy) {\n            viewRet.destroy()\n          }\n        },\n      }\n    }\n\n    const options = this.options.ySyncOptions\n    const onFirstRender = this.options.onFirstRender\n    const ySyncPluginOptions: YSyncOpts = {\n      ...(options ? { ...options } : {}),\n      ...(onFirstRender ? { onFirstRender } : {}),\n    }\n\n    const ySyncPluginInstance = ySyncPlugin(fragment, ySyncPluginOptions)\n\n    return [ySyncPluginInstance, yUndoPluginInstance]\n  },\n})\n", "import { Transaction } from '@tiptap/pm/state'\nimport { ySyncPluginKey } from 'y-prosemirror'\n\n/**\n * Checks if a transaction was originated from a Yjs change.\n * @param {Transaction} transaction - The transaction to check.\n * @returns {boolean} - True if the transaction was originated from a Yjs change, false otherwise.\n * @example\n * const transaction = new Transaction(doc)\n * const isOrigin = isChangeOrigin(transaction) // returns false\n */\nexport function isChangeOrigin(transaction: Transaction): boolean {\n  return !!transaction.getMeta(ySyncPluginKey)\n}\n"],
  "mappings": "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",
  "names": ["snapshot", "doc", "keys", "undoManager"]
}
