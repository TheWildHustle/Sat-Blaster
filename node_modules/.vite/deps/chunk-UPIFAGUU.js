// node_modules/irisdb/dist/irisdb.es.js
var M = Object.defineProperty;
var N = (g, t, e) => t in g ? M(g, t, { enumerable: true, configurable: true, writable: true, value: e }) : g[t] = e;
var d = (g, t, e) => (N(g, typeof t != "symbol" ? t + "" : t, e), e);
var O = class {
  constructor(t) {
    d(this, "channel");
    this.channel = new BroadcastChannel(t);
  }
  get(t, e) {
    const s = (i) => {
      const { path: n, value: o, updatedAt: c } = JSON.parse(i.data);
      n === t && e(
        o,
        t,
        c,
        () => this.channel.removeEventListener("message", s)
      );
    };
    return this.channel.addEventListener("message", s), () => this.channel.removeEventListener("message", s);
  }
  async set(t, e) {
    if (e && e.updatedAt === void 0)
      throw new Error(`Invalid value: ${JSON.stringify(e)}`);
    const s = JSON.stringify({
      path: t,
      value: e.value,
      updatedAt: e.updatedAt
    });
    this.channel.postMessage(s);
  }
  list(t, e) {
    const s = (i) => {
      const { path: n, value: o, updatedAt: c } = JSON.parse(i.data);
      if (n.startsWith(`${t}/`)) {
        const r = n.substring(t.length + 1);
        r.includes("/") || e(
          o,
          r,
          c,
          () => this.channel.removeEventListener("message", s)
        );
      }
    };
    return this.channel.addEventListener("message", s), () => this.channel.removeEventListener("message", s);
  }
};
var w = class {
  constructor() {
    d(this, "storage", /* @__PURE__ */ new Map());
    d(this, "isLoaded", false);
    d(this, "loadingPromise");
    d(this, "resolveLoading", null);
    this.loadingPromise = new Promise((t) => {
      this.resolveLoading = t;
    }), this.loadFromLocalStorage();
  }
  loadFromLocalStorage() {
    for (let t = 0; t < localStorage.length; t++) {
      const e = localStorage.key(t);
      let s;
      try {
        s = localStorage.getItem(e) || "", s = JSON.parse(s);
      } catch {
      }
      this.storage.set(e, s);
    }
    this.isLoaded = true, this.resolveLoading && this.resolveLoading();
  }
  listFromStorage(t, e) {
    for (const [s, i] of this.storage) {
      const n = s.replace(`${t}/`, "");
      s.startsWith(`${t}/`) && n.length && !n.includes("/") && e(i.value, s, i.updatedAt, () => {
      });
    }
  }
  get(t, e) {
    const s = this.storage.get(t) || { value: void 0, updatedAt: void 0 };
    return e(s.value, t, s.updatedAt, () => {
    }), this.isLoaded || this.loadingPromise.then(() => {
      const i = this.storage.get(t) || { value: void 0, updatedAt: void 0 };
      i !== s && e(i.value, t, i.updatedAt, () => {
      });
    }), () => {
    };
  }
  async set(t, e) {
    if (e.updatedAt === void 0)
      throw new Error(`Invalid value: ${JSON.stringify(e)}`);
    this.storage.set(t, e), localStorage.setItem(t, JSON.stringify(e));
  }
  list(t, e) {
    return this.listFromStorage(t, e), this.isLoaded || this.loadingPromise.then(() => {
      this.listFromStorage(t, e);
    }), () => {
    };
  }
};
var V = class {
  constructor() {
    d(this, "storage", /* @__PURE__ */ new Map());
  }
  get(t, e) {
    const s = this.storage.get(t) || { value: void 0, updatedAt: void 0 };
    return e(s.value, t, s.updatedAt, () => {
    }), () => {
    };
  }
  async set(t, e) {
    if (e.updatedAt === void 0)
      throw new Error(`Invalid value: ${JSON.stringify(e)}`);
    e === void 0 ? this.storage.delete(t) : this.storage.set(t, e);
  }
  list(t, e) {
    for (const [s, i] of this.storage) {
      const n = s.replace(`${t}/`, "");
      s.startsWith(`${t}/`) && n.length && !n.includes("/") && e(i.value, s, i.updatedAt, () => {
      });
    }
    return () => {
    };
  }
};
var C = Object.freeze(Object.defineProperty({
  __proto__: null,
  BroadcastChannelAdapter: O,
  LocalStorageMemoryAdapter: w,
  MemoryAdapter: V
}, Symbol.toStringTag, { value: "Module" }));
var L = {};
var S = (g) => typeof g == "object" && g !== null && // length 0
Object.keys(g).length === 0 && !Array.isArray(g);
var E = class _E {
  /**
   */
  constructor({ id: t = "", adapters: e, parent: s = null } = {}) {
    d(this, "id");
    d(this, "parent");
    d(this, "children", /* @__PURE__ */ new Map());
    d(this, "onSubscriptions", /* @__PURE__ */ new Map());
    d(this, "forEachSubscriptions", /* @__PURE__ */ new Map());
    d(this, "adapters");
    d(this, "counter", 0);
    this.id = t, this.parent = s, this.adapters = e ?? (s == null ? void 0 : s.adapters) ?? [new w()];
  }
  /**
   * Get a child node
   * @param key
   * @returns {Node}
   * @example node.get('apps/canvas/documents/test').put({name: 'Test Document'})
   * @example node.get('apps').get('canvas').get('documents').get('test').on((value) => console.log(`Document name: ${value.name}`))
   */
  get(t) {
    const e = t.split("/");
    let s = this.children.get(e[0]);
    return s || (s = new _E({ id: `${this.id}/${e[0]}`, parent: this }), this.children.set(e[0], s)), e.length > 1 ? s.get(e.slice(1).join("/")) : s;
  }
  async putValue(t, e, s) {
    S(t) || (this.children = /* @__PURE__ */ new Map());
    const i = {
      updatedAt: e,
      value: t,
      expiresAt: s
    }, n = this.adapters.map((o) => o.set(this.id, i));
    this.notifyChange(t, e), await Promise.all(n);
  }
  async putChildValues(t, e, s) {
    const i = this.adapters.map(
      (c) => c.set(this.id, { value: L, updatedAt: e, expiresAt: s })
    ), o = Object.keys(t).map((c) => this.get(c).put(t[c], e));
    await Promise.all([...i, ...o]);
  }
  /**
   * Set a value to the node. If the value is an object, it will be converted to child nodes.
   * @param value
   * @example node.get('apps/canvas/documents/test').put({name: 'Test Canvas'})
   */
  async put(t, e = Date.now(), s) {
    if (typeof t == "object" && t !== null && !Array.isArray(t) && Object.keys(t).length ? await this.putChildValues(t, e, s) : await this.putValue(t, e, s), this.parent) {
      await this.parent.put(L, e);
      const i = this.id.split("/").pop();
      this.parent.children.has(i) || this.parent.children.set(i, this);
      for (const [n, { callback: o, recursion: c }] of this.parent.forEachSubscriptions)
        (!S(t) || c === 0) && o(t, this.id, e, () => {
          var r;
          (r = this.parent) == null || r.forEachSubscriptions.delete(n);
        });
    }
  }
  /**
   * Subscribe to all child nodes, returned in the same object
   */
  open(t, e = 0, s = (i) => i) {
    const i = {};
    let n;
    return this.forEach((o, c, r) => {
      r !== void 0 && (!n || n < r) && (n = r);
      const u = c.split("/").pop();
      i[u] = o, t(s(i), c.split("/").slice(0, -1).join("/"), n, () => {
      });
    }, e);
  }
  /**
   * Subscribe to the node's value
   */
  on(t, e = false, s = 1, i = (o) => o, n = true) {
    let o = null;
    const c = /* @__PURE__ */ new Map();
    let r;
    const u = this.counter++, m = (a, h, l, p) => {
      const y = o !== null && l !== void 0 && o.updatedAt >= l;
      if (!e && a === void 0 || n && y)
        return;
      if (!n && l !== void 0) {
        const v = c.get(h);
        if (v && v.updatedAt >= l)
          return;
        c.set(h, { value: a, updatedAt: l });
      }
      if (!o && e && a === void 0) {
        t(a, h, l, p);
        return;
      }
      a !== void 0 && l !== void 0 && (o = { value: a, updatedAt: l }), S(a) && s > 0 && !r && (r = this.open(t, s - 1, i)), (!S(a) || s === 0) && t(i(a), h, l, p);
    };
    this.onSubscriptions.set(u, { callback: m, recursion: s });
    const b = this.adapters.map((a) => a.get(this.id, m));
    return () => {
      this.onSubscriptions.delete(u), b.forEach((a) => a()), r == null || r();
    };
  }
  notifyChange(t, e) {
    this.onSubscriptions.forEach(({ callback: s, recursion: i }) => {
      i > 0 && S(t) || s(t, this.id, e, () => {
      });
    });
  }
  /**
   * Subscribe to child nodes
   * @param callback
   */
  forEach(t, e = 0, s = (i) => i) {
    const i = this.counter++, n = (f, a, h, l) => {
      t(s(f), a, h, l);
    };
    this.forEachSubscriptions.set(i, { callback: n, recursion: e });
    const o = /* @__PURE__ */ new Map();
    let c = [];
    const r = {}, u = () => {
      c.forEach((f) => f());
    }, m = (f, a, h) => {
      const l = o.get(a);
      if (h !== void 0 && l && l.updatedAt >= h)
        return;
      h !== void 0 && o.set(a, { value: f, updatedAt: h });
      const p = a.split("/").pop();
      e > 0 && f && S(f) ? r[p] || (r[p] = this.get(p).open(t, e - 1)) : t(f, a, h, () => {
        this.forEachSubscriptions.delete(i), u(), Object.values(r).forEach((y) => y());
      });
    };
    return c = this.adapters.map(
      (f) => f.list(this.id, (a, h, l, p) => (m(s(a), h, l), () => {
      }))
    ), () => {
      this.forEachSubscriptions.delete(i), u(), Object.values(r).forEach((f) => f());
    };
  }
  /**
   * Same as on(), but will unsubscribe after the first callback
   * @param callback
   */
  once(t, e = false, s = 1, i = (n) => n) {
    return new Promise((n) => {
      let o = false;
      const c = (r, u, m, b) => {
        o || (o = true, n(r), t == null || t(r, u, m, () => {
        }), b());
      };
      this.on(c, e, s, i);
    });
  }
};
var P = "localState";
var J = new E({
  id: P,
  adapters: [new w(), new O(P)]
});

export {
  C,
  L,
  S,
  E,
  J
};
//# sourceMappingURL=chunk-UPIFAGUU.js.map
