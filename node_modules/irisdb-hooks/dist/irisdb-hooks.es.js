import { PublicKey as k, ndk as E, Hex as K, publicState as A } from "irisdb-nostr";
import { useEffect as d, useState as g, useCallback as N, useMemo as b } from "react";
import { localState as x } from "irisdb";
function p(t, s, e, n = (f) => f, r = !1, u = 1, S = !0) {
  d(() => {
    S && !e && t.get(s).once(
      (i) => {
        e = n(i);
      },
      void 0,
      u
    );
  }, [t, s, e]);
  const [f, c] = g(S ? e : /* @__PURE__ */ new Map());
  d(() => t.get(s).on(
    (o, a, m, w) => {
      c(S ? n(o) : (M) => {
        const h = new Map(M);
        return h.set(a, n(o)), h;
      }), r && w();
    },
    void 0,
    u,
    void 0,
    S
  ), [t, s, r]);
  const l = N(
    (i) => {
      t.get(s).put(i);
    },
    [t, s]
  );
  return [f, l];
}
function v(t, s, e, n, r = !1, u = 1) {
  return p(t, s, e, n, r, u, !0);
}
function B(t, s, e, n = !1, r = 1) {
  return p(t, s, void 0, e, n, r, !1);
}
function H(t, s, e = (r) => r, n = 1) {
  return v(x, t, s, e, !1, n);
}
function L(t, s) {
  const [e] = H("user/publicKey", ""), n = b(() => t ? t === "follows" ? e ? [String(e)] : [] : [new k(t).toString()] : [], [e, t]), [r, u] = g(new Set(n));
  return d(() => {
    if (e && t === "follows") {
      const f = E().subscribe({ kinds: [3], authors: [String(e)] });
      return f.on("event", (c) => {
        if (c.kind === 3) {
          const l = /* @__PURE__ */ new Set([String(e)]);
          let i = !1;
          c.tags.forEach((o) => {
            if (o[0] === "p")
              try {
                new K(o[1], 64), l.has(o[1]) || (l.add(o[1]), i = !0);
              } catch {
                console.error("Invalid public key", o[1]);
              }
          }), i && u(l);
        }
      }), () => f.stop();
    }
  }, [t, e]), d(() => {
    const f = new Set(n);
    if ((!r || Array.from(r).sort().toString() !== Array.from(f).sort().toString()) && u(f), !(!t || t === "follows") && s)
      return A(t).get(s).forEach(
        (c, l) => {
          u((i) => {
            const o = l.split("/").pop(), a = new Set(i), m = a.has(o);
            return c && !m ? (a.add(o), a) : !c && m ? (a.delete(o), a) : i;
          });
        },
        0,
        Boolean
      );
  }, [t, s, n]), b(() => Array.from(r), [r]);
}
function j(t, s, e, n, r = 1) {
  const u = b(() => A(t), [t]);
  return v(u, s, e, n, !1, r);
}
function q(t, s, e, n = 1) {
  const r = b(() => A(t), [t]);
  return B(r, s, e, !1, n);
}
export {
  L as useAuthors,
  H as useLocalState,
  v as useNodeState,
  q as usePublicGroupState,
  j as usePublicState
};
